# 第七章：事件总线

## 7.1 事件总线概述

事件总线（Event Bus）是一种用于组件间通信的设计模式，它可以解耦不同组件之间的直接依赖关系。在 Android 开发中，事件总线常用于在 Activity、Fragment、Service 等组件之间传递数据和事件。

本项目使用的是自研的 [XEventBus](file:///D:/git/app/AndroidProject/library/xbus/src/main/java/com/lucas/xbus/XEventBus.java#L26-L205) 框架，它比流行的 EventBus 框架更加轻量级，并且支持反射和 APT 两种方式。

## 7.2 为什么使用事件总线

在项目 [HelpDoc.md](file:///D:/git/app/AndroidProject/HelpDoc.md) 中提到，作者曾经加入过 EventBus，但在 [v10.0](https://github.com/getActivity/AndroidProject/releases/tag/10.0) 版本中移除了，原因是：

1. **不是必需品**：EventBus 不是项目的必需组件
2. **容易滥用**：在实际项目中经常被滥用
3. **建议正常通信**：能用正常方式实现通讯的，尽量不要用 EventBus

尽管如此，项目中仍然保留了自己的事件总线实现 [XEventBus](file:///D:/git/app/AndroidProject/library/xbus/src/main/java/com/lucas/xbus/XEventBus.java#L26-L205)，并在一些地方使用。

## 7.3 XEventBus 基本使用

### 注册和注销事件监听

在需要接收事件的组件中注册事件监听：

```java
public class MainActivity extends AppActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // 注册事件监听
        XEventBus.getDefault().register(this);
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        
        // 注销事件监听
        XEventBus.getDefault().unregister(this);
    }
}
```

### 定义事件类

创建一个简单的事件类：

```java
public class LoginEventNotification {
    private boolean loginNotification;
    
    public LoginEventNotification(boolean loginNotification) {
        this.loginNotification = loginNotification;
    }
    
    public boolean getLoginNotification() {
        return loginNotification;
    }
}
```

### 发送事件

在需要发送事件的地方：

```java
// 发送登录事件
XEventBus.getDefault().post(new LoginEventNotification(true));
```

### 接收事件

使用 [@Subscribe](file:///D:/git/app/AndroidProject/library/xbus/src/main/java/com/lucas/annotations/Subscribe.java#L27-L34) 注解标记接收事件的方法：

```java
@Subscribe
public void onEvent(LoginEventNotification event) {
    if (event.getLoginNotification()) {
        // 处理登录成功的逻辑
        ToastUtils.showShort("登录成功");
    }
}
```

## 7.4 项目中的事件类

项目中定义了一些事件类，用于特定场景的通信：

### LoginEventNotification 登录事件

用于通知登录状态的变化：

```java
public class LoginEventNotification {
    private boolean loginNotification;
    
    public LoginEventNotification(boolean loginNotification) {
        this.loginNotification = loginNotification;
    }
    
    public boolean getLoginNotification() {
        return loginNotification;
    }
}
```

### ChatMessageBeanEvent 聊天消息事件

用于聊天界面的消息处理：

```java
public class ChatMessageBeanEvent {
    private boolean isClear = false;
    private boolean assistantName = false;
    
    public boolean isAssistantName() {
        return assistantName;
    }
    
    public ChatMessageBeanEvent setAssistantName(boolean assistantName) {
        this.assistantName = assistantName;
        return this;
    }
    
    public boolean isClear() {
        return isClear;
    }
    
    public ChatMessageBeanEvent setClear(boolean clear) {
        isClear = clear;
        return this;
    }
}
```

### TipsFragmentSettingEventNotification 提示设置事件

用于通知提示设置的变化：

```java
public class TipsFragmentSettingEventNotification {
    private boolean settingNotification;
    
    public TipsFragmentSettingEventNotification(boolean settingNotification) {
        this.settingNotification = settingNotification;
    }
    
    public boolean getSettingNotification() {
        return settingNotification;
    }
}
```

## 7.5 在项目中的实际应用

### 在 Application 中初始化

在 [AppApplication](file:///D:/git/app/AndroidProject/app/src/main/java/run/yigou/gxzy/app/AppApplication.java#L58-L317) 中注册事件总线：

```java
public class AppApplication extends Application {
    
    @Override
    public void onCreate() {
        super.onCreate();
        
        // 以反射方式注册
        registryByReflect();
    }
    
    /**
     * 方法一：以反射调用
     */
    public void registryByReflect() {
        XEventBus.getDefault().register(this);
    }
    
    @Subscribe
    public void onDummyEvent(Object event) {
        // 空实现，仅为满足XEventBus注册要求
    }
    
    @Override
    public void onTerminate() {
        super.onTerminate();
        
        // 注销事件总线
        XEventBus.getDefault().unregister(this);
    }
}
```

### 在 Activity 中使用

在 Activity 中接收和发送事件：

```java
public class HomeActivity extends AppActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_home);
        
        // 注册事件监听
        // XEventBus.getDefault().register(this);
    }
    
    // 接收登录事件
    // @Subscribe(priority = 1)
    // public void onEvent(LoginEventNotification event) {
    //     if (event.getLoginNotification()) {
    //         // 处理登录逻辑
    //     }
    // }
}
```

### 在 Fragment 中使用

在 Fragment 中使用事件总线：

```java
public class TipsSettingFragment extends AppFragment<AppActivity> 
        implements SwitchButton.OnCheckedChangeListener {
    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 注册事件监听
        XEventBus.getDefault().register(this);
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy();
        
        // 注销事件监听
        XEventBus.getDefault().unregister(this);
    }
    
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        // 发送设置变化事件
        XEventBus.getDefault().post(
            new TipsFragmentSettingEventNotification(true));
    }
}
```

## 7.6 事件总线的优势和注意事项

### 优势

1. **解耦组件**：组件之间不需要直接引用对方就可以通信
2. **简化代码**：避免了大量接口回调的代码
3. **灵活通信**：可以在任意组件间传递事件

### 注意事项

1. **及时注销**：在组件销毁时要及时注销事件监听，避免内存泄漏
2. **避免滥用**：不要把所有组件间通信都用事件总线，适度使用
3. **事件类设计**：事件类应该尽量简单，避免携带复杂对象
4. **线程安全**：注意事件处理的线程环境

## 7.7 最佳实践

### 合理使用事件总线

```java
public class MessageCenterActivity extends AppActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_message_center);
        
        // 只在必要时注册事件监听
        XEventBus.getDefault().register(this);
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        
        // 务必注销事件监听
        XEventBus.getDefault().unregister(this);
    }
    
    // 处理聊天消息事件
    @Subscribe
    public void onChatMessage(ChatMessageBeanEvent event) {
        if (event.isClear()) {
            // 清空聊天记录
            clearChatMessages();
        }
    }
    
    private void clearChatMessages() {
        // 清空聊天记录的实现
    }
}
```

### 事件类的设计原则

```java
// 好的事件类设计
public class DataUpdateEvent {
    private int dataType;  // 数据类型
    private long itemId;   // 项目ID
    
    public DataUpdateEvent(int dataType, long itemId) {
        this.dataType = dataType;
        this.itemId = itemId;
    }
    
    // getter 方法
    public int getDataType() { return dataType; }
    public long getItemId() { return itemId; }
}

// 避免在事件类中携带复杂对象
public class BadEvent {
    private ComplexObject complexObject; // 不推荐
    private List<LargeData> dataList;    // 不推荐
    
    // 这样会增加内存消耗和潜在的内存泄漏风险
}
```

## 本章小结

这一章我们学习了：

1. 事件总线的概念和作用
2. 为什么在项目中使用 XEventBus
3. XEventBus 的基本使用方法
4. 项目中定义的事件类
5. 事件总线在项目中的实际应用场景
6. 使用事件总线的优势和注意事项
7. 事件总线的最佳实践

通过学习本章内容，你应该能够理解事件总线的工作原理，并能够在适当的时候使用它来简化组件间的通信。